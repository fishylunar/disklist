{
  "version": 3,
  "sources": ["../src/platform-factory.ts", "../src/platforms/base-platform.ts", "../src/utils.ts", "../src/errors.ts", "../src/platforms/windows-platform.ts", "../src/platforms/macos-platform.ts", "../src/platforms/linux-platform.ts", "../src/index.ts"],
  "sourcesContent": ["import os from \"node:os\";\nimport { BasePlatform } from \"./platforms/base-platform.ts\";\nimport { WindowsPlatform } from \"./platforms/windows-platform.ts\";\nimport { MacOSPlatform } from \"./platforms/macos-platform.ts\";\nimport { LinuxPlatform } from \"./platforms/linux-platform.ts\";\nimport { UnsupportedPlatformError } from \"./errors.ts\";\n\nexport class PlatformFactory {\n  static getPlatform(): BasePlatform {\n    const platform = os.platform();\n\n    switch (platform) {\n      case \"win32\":\n        return new WindowsPlatform();\n      case \"darwin\":\n        return new MacOSPlatform();\n      case \"linux\":\n        return new LinuxPlatform();\n      default:\n        throw new UnsupportedPlatformError(platform);\n    }\n  }\n}\n", "import { Drive } from \"../types.ts\";\n\nexport abstract class BasePlatform {\n  abstract getDrives(): Drive[];\n\n  protected standardizeDrive(drive: Partial<Drive>): Drive {\n    return {\n      device: drive.device ?? \"\",\n      displayName: drive.displayName ?? \"Unknown Drive\",\n      description: drive.description ?? \"Unknown\",\n      size: drive.size ?? 0,\n      mountpoints: drive.mountpoints ?? [],\n      raw: drive.raw ?? \"\",\n      protected: drive.protected ?? false,\n      system: drive.system ?? false,\n      removable: drive.removable ?? false,\n      fileSystem: drive.fileSystem ?? \"Unknown\",\n      driveType: drive.driveType ?? \"Unknown\",\n      mounted: drive.mounted ?? false,\n      serialNumber: drive.serialNumber,\n    };\n  }\n}\n", "import { execSync } from \"node:child_process\";\nimport { CommandExecutionError } from \"./errors.ts\";\nimport { Drive, FilterOptions, MacOSDiskDevice } from \"./types.ts\";\nimport { createHash } from \"node:crypto\";\nexport class DiskListUtils {\n  /**\n   * Safely executes a shell command and returns its output\n   */\n  static executeCommand(\n    command: string,\n    options: { shell?: string } = {},\n  ): string {\n    try {\n      return execSync(command, options).toString().trim();\n    } catch (error) {\n      throw new CommandExecutionError(\n        command,\n        error instanceof Error ? error.message : \"Unknown error\",\n      );\n    }\n  }\n\n  /**\n   * Parses plist output into JSON format (macOS specific)\n   */\n  static parsePlistOutput(plistStr: string): MacOSDiskDevice {\n    const escapedStr = plistStr.replace(/'/g, \"'\\\\''\");\n    return JSON.parse(\n      this.executeCommand(\n        `echo '${escapedStr}' | plutil -convert json -o - -`,\n        {\n          shell: \"/bin/bash\",\n        },\n      ),\n    );\n  }\n\n  /**\n   * Applies filters to an array of drives\n   */\n  static filterDrives(drives: Drive[], filter: FilterOptions): Drive[] {\n    if (!filter || Object.keys(filter).length === 0) {\n      return drives;\n    }\n\n    const { key, value, limit } = filter;\n\n    let filteredDrives = drives;\n\n    if (key && value !== undefined) {\n      filteredDrives = drives.filter((drive) => drive[key] === value);\n    }\n\n    if (typeof limit === \"number\") {\n      filteredDrives = filteredDrives.slice(0, limit);\n    }\n\n    return filteredDrives;\n  }\n\n  /**\n   * Converts size strings to bytes\n   */\n  static sizeToBytes(size: string | number): number {\n    if (typeof size === \"number\") return size;\n\n    const units = {\n      B: 1,\n      KB: 1024,\n      MB: 1024 ** 2,\n      GB: 1024 ** 3,\n      TB: 1024 ** 4,\n    };\n    const sizePattern = /^(\\d+(?:\\.\\d+)?)\\s*([KMGT]B|B)$/i;\n    const match = sizePattern.exec(size);\n\n    if (!match) return 0;\n\n    const [, value, unit] = match;\n    return Math.floor(parseFloat(value) * units[unit as keyof typeof units]);\n  }\n\n  /**\n   * getDriveNameMacOS - Gets the display name of a disk/volume on macOS\n   * @param diskName Name of the disk\n   * @returns {string | null} DisplayName of the disk - Returns undefined if no name was found.\n   */\n  static getDriveNameMacOS(diskName: string): string | undefined {\n    try {\n      const infoStr = execSync(`diskutil info -plist ${diskName}s1`).toString();\n      const parsed = this.parsePlistOutput(infoStr);\n      return parsed.VolumeName || parsed.MediaName || \"Unnamed Disk\";\n    } catch (error) {\n      console.error(`Error getting name for disk ${diskName}:`, error);\n      return undefined;\n    }\n  }\n  /**\n   * getDriveNameMacOS - Gets the display name of a disk/volume on macOS\n   * @param diskName Name of the disk\n   * @returns {string | null} DisplayName of the disk - Returns undefined if no name was found.\n   */\n  static getFileSystemNameMacOS(diskName: string): string | undefined {\n    try {\n      const infoStr = execSync(`diskutil info -plist ${diskName}s1`).toString();\n      const parsed = this.parsePlistOutput(infoStr);\n      let fsString = parsed.FilesystemUserVisibleName ||\n        parsed.FilesystemName || \"Unnamed Disk\";\n      if (fsString.includes(\"(\")) {\n        fsString = fsString.split(\"(\")[1].replace(\")\", \"\").trim();\n      }\n      return fsString;\n    } catch (error) {\n      console.error(`Error getting name for disk ${diskName}:`, error);\n      return undefined;\n    }\n  }\n  /** Attempt to unify the drive.descripton */\n  static serializeDescriptionString(description: string): string {\n    switch (description) {\n      case \"Storage Device\":\n        return \"USB Mass Storage Device\";\n      case \"Mass Storage Device USB Device\":\n        return \"USB Mass Storage Device\";\n      default:\n        return description;\n    }\n  }\n\n  /** Attempt to unify the drive.driveType */\n  static serializeDriveTypeString(driveTupe: string): string {\n    switch (driveTupe) {\n      case \"Removable Media\":\n        return \"USB Drive\";\n      case \"USB\":\n        return \"USB Drive\";\n      default:\n        return driveTupe;\n    }\n  }\n\n  /** Generate drive serial number */\n  static generateSerialNumber(drive: Drive): string {\n    // TODO: unify sizes. For now we use the first 4 chars of the Drive.size\n    const sizeString = drive.size.toString().substring(0, 4);\n    const serialString = drive.displayName + drive.description +\n      drive.removable + drive.fileSystem + sizeString + drive.driveType +\n      drive.system;\n    return createHash(\"md5\").update(serialString).digest(\"hex\");\n  }\n}\n", "/**\n * Custom error types for DiskList operations\n */\nexport class DiskListError extends Error {\n  constructor(message: string, public code: string) {\n    super(message);\n    this.name = \"DiskListError\";\n  }\n}\n\nexport class UnsupportedPlatformError extends DiskListError {\n  constructor(platform: string) {\n    super(`Platform '${platform}' is not supported`, \"UNSUPPORTED_PLATFORM\");\n  }\n}\n\nexport class CommandExecutionError extends DiskListError {\n  constructor(command: string, error: string) {\n    super(\n      `Failed to execute command '${command}': ${error}`,\n      \"COMMAND_EXECUTION_ERROR\",\n    );\n  }\n}\n", "import { BasePlatform } from \"./base-platform.ts\";\nimport { Drive, WindowsDrive, WindowsVolume } from \"../types.ts\";\nimport { DiskListUtils } from \"../utils.ts\";\n\nexport class WindowsPlatform extends BasePlatform {\n  getDrives(): Drive[] {\n    const volumeInfo = this.getVolumeInfo();\n    let physicalDrives = this.getPhysicalDrives();\n    // Check if physicalDrives is an array, if not make it an array\n    if (!Array.isArray(physicalDrives)) {\n      physicalDrives = [physicalDrives];\n    }\n\n    return physicalDrives.map((drive: WindowsDrive, index: number) => {\n      const volume = volumeInfo.filter((vol: WindowsVolume) =>\n        vol.DriveLetter?.includes(\":\")\n      )[index];\n\n      const standarizedDrive = this.standardizeDrive({\n        device: drive.Name,\n        displayName: volume?.Label, //volume?.DriveLetter ?? drive.Name,\n        description: DiskListUtils.serializeDescriptionString(drive.Model) ??\n          \"Unknown\",\n        size: drive.Size,\n        mountpoints: volume?.DriveLetter\n          ? [{ path: `${volume.DriveLetter}/` }]\n          : [],\n        raw: drive.Name,\n        protected: volume.IsReadOnly !== 0,\n        system: volume?.BootVolume ?? false,\n        // Removed because it's the same as displayName.\n        // label: volume?.Label ?? 'Unnamed Drive',\n        removable: drive.MediaType === \"Removable Media\",\n        fileSystem: volume?.FileSystem ?? \"Unknown\",\n        driveType: DiskListUtils.serializeDriveTypeString(drive.MediaType) ??\n          \"Unknown\",\n        mounted: !!volume?.DriveLetter,\n        serialNumber: drive.SerialNumber, // We change this later\n        // healthStatus: drive.Status\n      });\n\n      // Update the serial number of the drive\n      standarizedDrive.serialNumber = DiskListUtils.generateSerialNumber(\n        standarizedDrive,\n      );\n      return standarizedDrive;\n    });\n  }\n\n  private getVolumeInfo() {\n    const command = `\n      Get-CimInstance Win32_Volume |\n      Where-Object { $_.DriveType -eq 2 -or $_.DriveType -eq 3 } |\n      Select-Object DriveLetter, FileSystem, Label, BootVolume,\n                    @{N='IsReadOnly';E={$_.Attributes -band 1}} |\n      ConvertTo-Json\n    `;\n    return JSON.parse(\n      DiskListUtils.executeCommand(command, { shell: \"powershell.exe\" }),\n    );\n  }\n\n  private getPhysicalDrives() {\n    const command = `\n      Get-CimInstance Win32_DiskDrive |\n      Select-Object Model, Size, MediaType, Name, SerialNumber, Status |\n      ConvertTo-Json\n    `;\n    return JSON.parse(\n      DiskListUtils.executeCommand(command, { shell: \"powershell.exe\" }),\n    );\n  }\n}\n", "import { BasePlatform } from \"./base-platform.ts\";\nimport { Drive, MacOSDiskDevice } from \"../types.ts\";\nimport { DiskListUtils } from \"../utils.ts\";\n\nexport class MacOSPlatform extends BasePlatform {\n  getDrives(): Drive[] {\n    const diskList = DiskListUtils.parsePlistOutput(\n      DiskListUtils.executeCommand(\"diskutil list -plist\"),\n    );\n\n    return diskList.AllDisksAndPartitions\n      .map((disk: MacOSDiskDevice) => {\n        const diskInfo = this.getDiskInfo(disk.DeviceIdentifier);\n        if (!diskInfo || diskInfo.BusProtocol === \"Disk Image\") {\n          return null;\n        }\n\n        const standarizedDrive = this.standardizeDrive({\n          device: diskInfo.DeviceNode,\n          displayName: DiskListUtils.getDriveNameMacOS(diskInfo.DeviceNode),\n          description: DiskListUtils.serializeDescriptionString(\n            diskInfo.MediaName || diskInfo.IORegistryEntryName,\n          ),\n          size: diskInfo.Size,\n          mountpoints: diskInfo.MountPoint\n            ? [{ path: diskInfo.MountPoint }]\n            : [],\n          raw: diskInfo.DeviceNode,\n          protected: !diskInfo.WritableMedia,\n          system: diskInfo.SystemImage || false,\n          // Removed because it's the same as displayName.\n          // label: volume?.Label ?? 'Unnamed Drive',\n          removable: diskInfo.RemovableMedia || diskInfo.Ejectable,\n          fileSystem:\n            DiskListUtils.getFileSystemNameMacOS(diskInfo.DeviceNode) ||\n            \"Unknown\",\n          driveType:\n            DiskListUtils.serializeDriveTypeString(diskInfo.BusProtocol) ||\n            \"Unknown\",\n          mounted: !!diskInfo.MountPoint,\n          // healthStatus: diskInfo.SMARTStatus,\n          serialNumber: \"\",\n        });\n        standarizedDrive.serialNumber = DiskListUtils.generateSerialNumber(\n          standarizedDrive,\n        );\n\n        return standarizedDrive;\n      })\n      .filter((drive: Drive | null): drive is Drive => drive !== null);\n  }\n\n  private getDiskInfo(diskName: string): MacOSDiskDevice {\n    const infoStr = DiskListUtils.executeCommand(\n      `diskutil info -plist /dev/${diskName}`,\n    );\n    return DiskListUtils.parsePlistOutput(infoStr);\n  }\n}\n", "import { BasePlatform } from \"./base-platform.ts\";\nimport { Drive, LinuxDevice } from \"../types.ts\";\nimport { DiskListUtils } from \"../utils.ts\";\n\nexport class LinuxPlatform extends BasePlatform {\n  getDrives(): Drive[] {\n    const blockDevices = this.getBlockDevices();\n\n    return blockDevices\n      .filter((device: LinuxDevice) => device.type === \"disk\")\n      .map((device: LinuxDevice) => {\n        const udevInfo = this.getUdevInfo(device.name);\n\n        return this.standardizeDrive({\n          device: `/dev/${device.name}`,\n          displayName: device.label || `/dev/${device.name}`,\n          description: udevInfo.model || \"Unknown\",\n          size: parseInt(device.size, 10),\n          mountpoints: device.mountpoint ? [{ path: device.mountpoint }] : [],\n          raw: `/dev/${device.name}`,\n          protected: device.ro === \"1\",\n          system: this.isSystemDrive(device.name),\n          removable: !!device.rm,\n          fileSystem: device.fstype || \"Unknown\",\n          driveType: udevInfo.type || \"Unknown\",\n          mounted: !!device.mountpoint,\n          serialNumber: udevInfo.serial,\n        });\n      });\n  }\n\n  private getBlockDevices() {\n    const command =\n      \"lsblk -J -b -o NAME,SIZE,RO,TYPE,MOUNTPOINT,LABEL,RM,FSTYPE\";\n    return JSON.parse(DiskListUtils.executeCommand(command)).blockdevices;\n  }\n\n  private getSmartInfo(deviceName: string) {\n    try {\n      const output = DiskListUtils.executeCommand(\n        `smartctl -H /dev/${deviceName}`,\n      );\n      return {\n        health: output.includes(\"PASSED\") ? \"Healthy\" : \"Warning\",\n      };\n    } catch {\n      return { health: \"Unknown\" };\n    }\n  }\n\n  private getUdevInfo(deviceName: string) {\n    const output = DiskListUtils.executeCommand(\n      `udevadm info --query=property --name=${deviceName}`,\n    );\n\n    const modelPattern = /ID_MODEL=(.*)/;\n    const typePattern = /ID_TYPE=(.*)/;\n    const serialPattern = /ID_SERIAL=(.*)/;\n\n    const modelMatch = modelPattern.exec(output);\n    const typeMatch = typePattern.exec(output);\n    const serialMatch = serialPattern.exec(output);\n\n    return {\n      model: modelMatch?.[1] || \"Unknown\",\n      type: typeMatch?.[1] || \"Unknown\",\n      serial: serialMatch?.[1],\n    };\n  }\n\n  private isSystemDrive(deviceName: string): boolean {\n    try {\n      const rootMount = DiskListUtils.executeCommand(\"findmnt / -n -o SOURCE\");\n      return rootMount.includes(deviceName);\n    } catch {\n      return false;\n    }\n  }\n}\n", "import { DiskListOptions, Drive } from \"./types.ts\";\nimport { PlatformFactory } from \"./platform-factory.ts\";\nimport { DiskListUtils } from \"./utils.ts\";\n\nexport default class DiskList {\n  /**\n   * Lists all drives on the system synchronously\n   * @param options Configuration options for drive listing\n   * @returns Array of standardized drive information\n   */\n  static listDrivesSync(\n    options: DiskListOptions = { returnOnlyRemovable: false, filter: {} },\n  ): Drive[] {\n    const platform = PlatformFactory.getPlatform();\n    let drives = platform.getDrives();\n\n    if (options.returnOnlyRemovable) {\n      drives = drives.filter((drive) => drive.removable);\n    }\n\n    return DiskListUtils.filterDrives(drives, options.filter);\n  }\n\n  /**\n   * Lists all drives on the system asynchronously\n   * @param options Configuration options for drive listing\n   * @returns Promise resolving to array of standardized drive information\n   */\n  static async listDrives(\n    options: DiskListOptions = { returnOnlyRemovable: false, filter: {} },\n  ): Promise<Drive[]> {\n    return await this.listDrivesSync(options);\n  }\n}\n\nexport * from \"./types.ts\";\nexport * from \"./errors.ts\";\n"],
  "mappings": "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",
  "names": ["os", "BasePlatform", "drive", "execSync", "DiskListError", "message", "code", "UnsupportedPlatformError", "platform", "CommandExecutionError", "command", "error", "createHash", "DiskListUtils", "command", "options", "execSync", "error", "CommandExecutionError", "plistStr", "escapedStr", "drives", "filter", "key", "value", "limit", "filteredDrives", "drive", "size", "units", "match", "unit", "diskName", "infoStr", "parsed", "fsString", "description", "driveTupe", "sizeString", "serialString", "WindowsPlatform", "BasePlatform", "volumeInfo", "physicalDrives", "drive", "index", "volume", "vol", "standarizedDrive", "DiskListUtils", "MacOSPlatform", "BasePlatform", "DiskListUtils", "disk", "diskInfo", "standarizedDrive", "drive", "diskName", "infoStr", "LinuxPlatform", "BasePlatform", "device", "udevInfo", "DiskListUtils", "deviceName", "output", "modelPattern", "typePattern", "serialPattern", "modelMatch", "typeMatch", "serialMatch", "PlatformFactory", "platform", "os", "WindowsPlatform", "MacOSPlatform", "LinuxPlatform", "UnsupportedPlatformError", "DiskList", "options", "drives", "PlatformFactory", "drive", "DiskListUtils"]
}
